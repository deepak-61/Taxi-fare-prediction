# -*- coding: utf-8 -*-
"""Course_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VlpHy5QHoDsthi-GrPYY34tH4BSB3hwF
"""

import pandas as pd

# Commented out IPython magic to ensure Python compatibility.
# %time
df = pd.read_csv('train.csv',nrows=5000000)



df.head()

df.info()

# Commented out IPython magic to ensure Python compatibility.
# %time
df['pickup_datetime'] = pd.to_datetime(df['pickup_datetime'], format= '%Y-%m-%d %H:%M:%S UTC')

df.info()

df.describe()

df = df.loc[df['pickup_latitude'].between(40,42)]
df = df.loc[df['pickup_longitude'].between(-75,-72)]
df = df.loc[df['dropoff_latitude'].between(40,42)]
df = df.loc[df['dropoff_longitude'].between(-75,-72)]
df = df.loc[df['fare_amount'] > 2.5]
df = df.loc[df['passenger_count'] > 0]

df.describe()

df.isnull().any()

import matplotlib.pyplot as plt

plt.figure(figsize=(14,4))
plt.hist(df['fare_amount'],1000, facecolor='blue')
plt.xlabel('Fare Amount')
plt.ylabel('Count')
plt.title('Histogram of Fare Amount')
plt.xlim(0,100)

df['passenger_count'].value_counts().plot.bar()
plt.title('Histogram of Passenger Count')
plt.xlabel('Passenger Count')
plt.ylabel('Frequency')

df.loc[df['passenger_count'] <= 6]

df['passenger_count'].value_counts()

"""1.Distance
2.Time of ride
3.Traffic
4.No. of Passengers
5.Pickup and dropoff locarions
"""

import folium

nyc = folium.Map(location=['40.730610', '-73.935242'], zoom_start=12)

nyc

for i in df.index[:100]:
    folium.CircleMarker(location=[df['pickup_latitude'][i],df['pickup_longitude'][i]], color='green').add_to(nyc)

nyc

for i in df.index[:100]:
    folium.CircleMarker(location=[df['dropoff_latitude'][i],df['dropoff_longitude'][i]], color='orange').add_to(nyc)

nyc

"""Feature Engineering

"""

df['year'] = df.pickup_datetime.dt.year
df['month'] = df.pickup_datetime.dt.month
df['day'] = df.pickup_datetime.dt.day
df['weekday'] = df.pickup_datetime.dt.weekday
df['hour'] = df.pickup_datetime.dt.hour

df.head()

import numpy as np

def haversine_np(lon1, lat1, lon2, lat2):
    """
    Calculate the great circle distance between two points
    on the earth (specified in decimal degrees)

    All args must be of equal length.

    """
    lon1, lat1, lon2, lat2 = map(np.radians, [lon1, lat1, lon2, lat2])

    dlon = lon2 - lon1
    dlat = lat2 - lat1

    a = np.sin(dlat/2.0)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2.0)**2

    c = 2 * np.arcsin(np.sqrt(a))
    km = 6378.137 * c
    return km

df['distance'] = haversine_np(df['pickup_latitude'],df['pickup_longitude'],df['dropoff_latitude'],df['dropoff_longitude'])

df.head()

import seaborn as sns

plt.figure(figsize=(14,4))
sns.distplot(df['distance'],bins=1000,color='green',kde=False)

df['distance'].describe()

df = df.loc[df['distance'] > 0]

"""Model Building"""

df.head()

del df['pickup_datetime']
del df['key']

from sklearn.model_selection import train_test_split

y = df['fare_amount']
X = df.drop(columns = ['fare_amount'])
X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.3,random_state=50)

"""Linear Regression Model"""

from sklearn.linear_model import LinearRegression

lr = LinearRegression()
lr.fit(X_train, y_train)
y_pred = lr.predict(X_test)

from sklearn.metrics import mean_squared_error

from math import sqrt
rms = sqrt(mean_squared_error(y_test, y_pred))

rms

"""Random Forest"""

# Commented out IPython magic to ensure Python compatibility.
# %time
from sklearn.ensemble import RandomForestRegressor
rf = RandomForestRegressor(max_depth=2,random_state=0,n_estimators=100)
rf.fit(X_train,y_train)
y_pred = rf.predict(X_test)

rms = sqrt(mean_squared_error(y_test, y_pred))
rms

"""LightGBM"""

import lightgbm as lgb

params = {
    'learning_rate':0.75,
    'application': 'regression',
    'max_depth':3,
    'num_leaves':100,
    'verbosity':-1,
    'metric': 'RMSE',
}

train_set = lgb.Dataset(X_train,y_train)

# Commented out IPython magic to ensure Python compatibility.
# %time
lb = lgb.train(params,train_set = train_set)

y_pred = lb.predict(X_test)

rms = sqrt(mean_squared_error(y_test,y_pred))
rms